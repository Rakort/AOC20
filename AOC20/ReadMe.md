##Оглавление

[День 1: Исправление отчета](#день-1-исправление-отчета)

[День 2: Философия паролей](#День-2-Философия-паролей)

[День 3: Траектория тобоггана](#День-3-Траектория-тобоггана)

[День 4: Оформление паспорта](#День-4-Оформление-паспорта)

[День 5: Бинарная посадка](#День-5-Бинарная-посадка)

[День 6: Таможня](#День-6-Таможня)

[День 7: Удобные рюкзаки](#День-7-Удобные-рюкзаки)

[День 8: Ручная остановка](#День-8-Ручная-остановка)

[День 9: Ошибка кодирования](#День-9-Ошибка-кодирования)

[День 10: Массив адаптеров](#День-10-Массив-адаптеров)

[День 11: Система рассадки](#День-11-Система-рассадки)

[День 12: Риск дождя](#День-12-Риск-дождя)

[День 13: Поиск автобуса](#День-13-Поиск-автобуса)

[День 14: Данные стыковки](#День-14-Данные-стыковки)

# День 1: Исправление отчета 
## Часть первая 
Прежде чем вы уйдете, эльфам-бухгалтерам просто нужно, чтобы вы исправили свой отчет о расходах (ввод головоломки); очевидно, что-то не совсем складывается.
В частности, им нужно, чтобы вы нашли две записи, которые в сумме дают 2020 а затем умножили эти два числа вместе.
Например, предположим, что ваш отчет о расходах содержит следующее:
```
1721
979
366
299
675
1456
```
В этом списке две записи сумма которых `2020` это `1721` и `299`. Их умножение дает `1721 * 299 = 514579`. Правильный ответ `514579`.

Конечно, ваш отчет о расходах намного больше. Найдите две записи, сумма которых равна 2020. Что вы получите, если умножите их вместе?

### Решение
Просто перебираем элементы в двух циклах складываем и сравниваем. Решение простое и выполняется за приемлемое время.

## Часть вторая 
Эльфы в бухгалтерском учете благодарны за вашу помощь; один из них даже предлагает вам монету с морской звездой, оставшуюся от прошлого отпуска. 
Они предлагают вам вторую, если вы найдете в своем отчете о расходах три числа, которые соответствуют тем же критериям.

Используя приведенный выше пример еще раз, три записи, сумма которых `2020` это `979`, `366` и `675`. Их умножение дает ответ `241861950`.

Каким будет произведение трех чисел в сумме дающих 2020 в вашем отчете о расходах?

### Решение
Добавляем еще один цикл. И все еще выполняется достаточно быстро.

# День 2: Философия паролей 
## Часть первая 
Ваш рейс вылетает через несколько дней из прибрежного аэропорта; Отсюда проще всего спуститься к побережью на тобоггане.

У владельца магазина проката тобогганов на Северном полюсе тяжелый день. «Что-то не так с нашими компьютерами; мы не можем войти в систему!» 
Вы спрашиваете, можете ли вы взглянуть.

Их база паролей кажется немного поврежденной: некоторые пароли не были разрешены официальной корпоративной политикой тобоггана, действовавшей на момент их выбора.

Чтобы попытаться отладить проблему, они создали список (ввод головоломки) паролей (в соответствии с поврежденной базой данных) и корпоративную политику, когда этот пароль был установлен.

Например, предположим, что у вас есть следующий список:

`1-3 a: abcde`
`1-3 b: cdefg`
`2-9 c: ccccccccc`

В каждой строке указывается политика паролей, а затем пароль. Политика паролей указывает наименьшее и наибольшее количество раз, когда данная буква должна появляться, чтобы пароль был действительным. Например, 1-3 a означает, что пароль должен содержать a минимум 1 раз и максимум 3 раза.

В приведенном выше примере 2 пароля действительны. Средний пароль `cdefg` нет; он не содержит экземпляров `b`, но требует как минимум 1. Первый и третий пароли действительны: они содержат один `a` или девять `c`, оба в пределах их соответствующих политик.

Сколько паролей действительны в соответствии с их политиками?

### Решение
Для хранения данных в удобном виде создаем класс. У него создаем конструктор который принимает на вход строку и парсит её с помощью регулярного выражения.
Для проверки валидности считаем количество символов соответствующих необходимому. И сверяем с макс и мин значениями.


## Часть вторая 
Хотя кажется, что вы правильно проверили пароли, похоже, они не соответствуют ожиданиям официальной системы аутентификации тобоггана.

Владелец магазина внезапно понимает, что он просто случайно объяснил правила политики паролей на своей старой работе в пункте проката саней на улице! Официальная корпоративная политика тобоггана на самом деле работает немного иначе.

Каждая политика фактически описывает две позиции в пароле, где 1 означает первый символ, 2 означает второй символ и так далее. (Будьте осторожны; в корпоративной политике тобоггана нет понятия «нулевой индекс»!) Ровно одна из этих позиций должна содержать данную букву. Другие случаи появления буквы не имеют значения для целей применения политики.

Учитывая тот же список примеров, приведенный выше:

`1-3 a: abcde` является действительным : положение 1 содержит `a` и положение 3 не содержит.
`1-3 b: cdefg` является недействительным : ни положение, 1 ни позиция 3 не содержит `b`.
`2-9 c: ccccccccc` является недействительным : как позиция 2, так и позиция 9 содержит `c`.
Сколько паролей действительны в соответствии с новой интерпретацией политик?

### Решение
В функции проверки валидности проверяем какие буквы содержатся в указынных позициях.

	let validMin = this.password.[this.min-1] = this.char
	let validMax = this.password.[this.max-1] = this.char
Если `validMin <> validMax` значит пароль действительный, т.е. только один из них содержит нужную букву


# День 3: Траектория тобоггана
## Часть первая
Решив проблемы с входом на тобогган, вы отправитесь в аэропорт. Хотя путешествие на тобоггане может быть легким, это определенно небезопасно: рулевое управление очень мало, а территория покрыта деревьями. Вам нужно будет посмотреть, под каким углом вы приблизитесь к наименьшему количеству деревьев.

Из-за местной геологии деревья в этой области растут только в точных целочисленных координатах в сетке. Вы составляете карту (вход в головоломку) из открытых квадратов ( .) и деревьев ( #), которые видите. Например:

```
..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#
```

Однако это не единственные деревья; из-за того, что вы однажды прочитали о генетике деревьев и стабильности биома, один и тот же шаблон повторяется вправо много раз:

```
..##.........##.........##.........##.........##.........##.......  >
\#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....  >
.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........#.#........#.#........#.#........#.#........#
\#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
\#...##....##...##....##...##....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#  >
```

Вы начинаете с открытого квадрата (.) в верхнем левом углу и должны достичь нижнего края (под самой нижней строкой на вашей карте).

Тобогган может двигаться только по нескольким определенным склонам (вы выбрали более дешевую модель, которая предпочитает рациональные числа); начните с подсчета всех деревьев, которые вы встретите на склоне 3 вправо и 1 вниз :

Из вашей начальной позиции в верхнем левом углу проверьте позицию, которая находится справа 3 и вниз 1. Затем проверьте позицию, которая находится справа 3 и вниз 1 оттуда, и так далее, пока вы не пройдете за нижнюю часть карты.

Места, которые вы бы отметили в приведенном выше примере, отмечены здесь тем, Oгде был открытый квадрат и Xгде было дерево:

```
..##.........##.........##.........##.........##.........##.......  >
\#..O#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....X..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#O#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..X...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.X#.......#.##.......#.##.......#.##.......#.##.....  >
.#.#.#....#.#.#.#.O..#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........X.#........#.#........#.#........#.#........#
\#.##...#...#.##...#...#.X#...#...#.##...#...#.##...#...#.##...#...
\#...##....##...##....##...#X....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...X.#.#..#...#.#.#..#...#.#.#..#...#.#  >
```

В этом примере при перемещении по карте с использованием этого уклона вы встретите 7деревья.

Сколько деревьев вы встретите, начиная с левого верхнего угла карты и следуя по склону 3 вправо и вниз 1 ?

### Решение
В задаче нам задали смещение (3 вправо, 1 вниз) каждый шаг прибавляем его к текущей позиции. 
Если позиция `x` выходит за пределы строки обрезаем её остатком от деления на длину строки.
Таким образом считаем деревья пока не дойдем до низу.

## Часть вторая 
Пора проверить остальные склоны - ведь вам нужно свести к минимуму вероятность внезапной остановки древесных пород.

Определите количество деревьев, с которыми вы столкнетесь, если для каждого из следующих склонов вы начнете с верхнего левого угла и пройдете карту полностью вниз:

1 вправо, 1 вниз.
3 вправо, 1 вниз. (Это наклон, который вы уже проверили.)
5 вправо, 1 вниз.
7 вправо, 1 вниз.
1 вправо, 2 вниз.
В приведенном выше примере, на этих склонах найдете 2, 7, 3, 4, и 2 дерева, соответственно; умноженные вместе, они дают ответ 336.

Что вы получите, если умножите количество деревьев, встречающихся на каждом из перечисленных склонов?

### Решение
Считаем количество деревьев с помощью метода из первой части и находим их произведение.

# День 4: Оформление паспорта 
## Часть первая
Вы прибываете в аэропорт только для того, чтобы понять, что взяли с собой учетные данные Северного полюса вместо паспорта. Хотя эти документы очень похожи, документы Северного полюса не выдаются страной, и следовательно, не являются действительными документами для путешествий в большинстве стран мира.

Но похоже, что проблемы есть не только у вас; сформировалась очень длинная очередь к автоматическим сканерам паспортов, и задержка может нарушить ваш маршрут поездки.

Из-за некоторой сомнительной сетевой безопасности вы понимаете, что можете решить обе эти проблемы одновременно.

Автоматические сканеры паспортов работают медленно, потому что им сложно определить, в каких паспортах есть все обязательные поля. 
Ожидаемые поля:

- `byr` (Год рождения)
- `iyr` (Год выпуска)
- `eyr` (Год истечения)
- `hgt` (Высота)
- `hcl` (Цвет волос)
- `ecl` (Цвет глаз)
- `pid` (Номер паспорта)
- `cid` (ID страны)

Данные паспорта проверяются в пакетных файлах (ввод вашей головоломки). Каждый паспорт представлен как последовательность `key:value` пар, разделенных пробелами или символами новой строки. Паспорта разделяются пустыми строками.

Вот пример командного файла, содержащего четыре паспорта:

```
ecl:gry pid:860033327 eyr:2020 hcl:#fffffd
byr:1937 iyr:2017 cid:147 hgt:183cm

iyr:2013 ecl:amb cid:350 eyr:2023 pid:028048884
hcl:#cfa07d byr:1929

hcl:#ae17e1 iyr:2013
eyr:2024
ecl:brn pid:760753108 byr:1931
hgt:179cm

hcl:#cfa07d eyr:2025 pid:166559648
iyr:2011 ecl:brn hgt:59in
```
Первый паспорт действителен - присутствуют все восемь полей. 

Второй паспорт недействителен - он отсутствует `hgt`(поле Высота).

Третий паспорт интересен; недостающим полем является только `cid`, поэтому он выглядит как данные из документов Северного полюса, а не паспорт у всех! Конечно, никто не будет возражать, если вы заставите систему временно игнорировать отсутствующие `cid` поля. Считайте этот «паспорт» действительным.

В четвертом паспорте отсутствуют два поля `cid` и `byr`. Отсутствие `cid` - это нормально, но отсутствие любого другого поля - нет, поэтому этот паспорт недействителен.

В соответствии с приведенными выше правилами ваша улучшенная система будет определять `2` действительных паспорта.

Подсчитайте количество действующих паспортов - тех, в которых есть все обязательные поля. Считать `cid` необязательным. Сколько действительных паспортов в вашем пакетном файле?

### Решение

Для начала парсим входные данные при помощи нескольких Split-ов. 
С помощью функции Array.except получаем массив элементов отсутствующие в списке обязательных полей. Если их больше `0`, то паспорт не действительный.
Далее считаем количество действительных паспортов.

## Часть вторая
Очередь сейчас движется быстрее, но вы слышите, как служба безопасности аэропорта говорит о том, как проходят паспорта с недействительными данными. Лучше добавить проверку данных, быстро!

Вы можете продолжать игнорировать это `cid` поле, но для каждого другого поля существуют строгие правила относительно того, какие значения допустимы для автоматической проверки:

- `byr` (Год рождения) - четыре цифры; минимум `1920` и максимум `2002`.
- `iyr` (Год выпуска) - четыре цифры; минимум `2010` и максимум `2020`.
- `eyr` (Срок годности) - четыре цифры; минимум `2020` и максимум `2030`.
- `hgt` (Высота) - число, за которым следует либо, `cm` либо `in`:
	* Если `cm`, число должно быть не меньше `150` и не больше `193`.
	* Если `in`, число должно быть не меньше `59` и не больше `76`.
- `hcl` (Цвет волос) - символ `#` за которым следует ровно шесть символов `0-9` или `a-f`.
- `ecl` (Цвет глаз) - точно один из: `amb blu brn gry grn hzl oth`.
- `pid` (Идентификатор паспорта) - девятизначное число, включая ведущие нули.
- `cid` (Country ID) - игнорируется, отсутствует или нет.
Ваша задача - подсчитать паспорта, в которых все обязательные поля присутствуют и действительны в соответствии с вышеуказанными правилами. Вот несколько примеров значений:
```
byr valid:   2002
byr invalid: 2003

hgt valid:   60in
hgt valid:   190cm
hgt invalid: 190in
hgt invalid: 190

hcl valid:   #123abc
hcl invalid: #123abz
hcl invalid: 123abc

ecl valid:   brn
ecl invalid: wat

pid valid:   000000001
pid invalid: 0123456789
```
Вот несколько недействительных паспортов:
```
eyr:1972 cid:100
hcl:#18171d ecl:amb hgt:170 pid:186cm iyr:2018 byr:1926

iyr:2019
hcl:#602927 eyr:1967 hgt:170cm
ecl:grn pid:012533040 byr:1946

hcl:dab227 iyr:2012
ecl:brn hgt:182cm pid:021572410 eyr:2020 byr:1992 cid:277

hgt:59cm ecl:zzz
eyr:2038 hcl:74454a iyr:2023
pid:3556412378 byr:2007
Вот несколько действующих паспортов:

pid:087499704 hgt:74in ecl:grn iyr:2012 eyr:2030 byr:1980
hcl:#623a2f

eyr:2029 ecl:blu cid:129 byr:1989
iyr:2014 pid:896056539 hcl:#a97842 hgt:165cm

hcl:#888785
hgt:164cm byr:2001 iyr:2015 cid:88
pid:545766238 ecl:hzl
eyr:2022

iyr:2010 hgt:158cm hcl:#b6652a ecl:blu byr:1944 eyr:2021 pid:093154719
```
Подсчитайте количество действующих паспортов - тех, у которых есть все обязательные поля и допустимые значения. Продолжать рассматривать `cid` как необязательный. Сколько действительных паспортов в вашем пакетном файле?

### Решение

Начинаем как в части 1 проверяем наличие обязательных полей. Затем проверяем каждое поле на достоверность, в основном с помощью регулярных выражений.

# День 5: Бинарная посадка
## Часть первая
Вы садитесь в самолет и обнаруживаете новую проблему: вы уронили посадочный талон! Вы не уверены, какое место ваше, и все бортпроводники заняты потоком людей, внезапно прошедших паспортный контроль.

Вы пишете быструю программу, которая использует камеру вашего телефона для сканирования всех ближайших посадочных талонов (вводная часть головоломки); возможно, вы сможете найти свое место в процессе исключения.

Вместо зон или групп эта авиакомпания использует двоичное разделение пространства для размещения людей. Сиденье может быть указано как `FBFBBFFRLR`, где `F` означает «переднее», `B` означает «заднее», `L` означает «левое» и `R` означает «правое».

Первые 7 символов будут либо `F` или `B`; они точно указать один из 128 строк на плоскости (пронумерованных от `0` до `127`). Каждая буква сообщает вам, в какой половине региона находится данное место. Начните со всего списка строк; первая буква указывает, находится ли сиденье спереди (от `0` до `63`) или сзади (от `64` до `127`). Следующая буква указывает, в какой половине этого региона находится сиденье, и так далее, пока не останется ровно один ряд.

Например, рассмотрим только первые семь символов `FBFBBFFRLR`:

- Начните с рассмотрения всего диапазона рядов от `0` до `127`.
- `F` значит взять нижнюю половину, сохраняя строки от `0` до `63`.
- `B` значит взять верхнюю половину, сохраняя строки от `32` до `63`.
- `F` значит взять нижнюю половину, сохраняя строки от `32` до `47`.
- `B` значит взять верхнюю половину, сохраняя строки от `40` до `47`.
- `B` держит ряды от `44` до `47`.
- `F` держит ряды от `44` до `45`.
- В финале `F` остается нижний из двух рядов `44`.

Последние три символа будут либо `L` или `R`; это точно указать один из 8 колонок сидений на плоскости (пронумерованных от `0` до `7`). Повторяется тот же процесс, что и выше, на этот раз всего с тремя шагами. `L` означает сохранить нижнюю половину, а `R` означает сохранить верхнюю половину.

Например, рассмотрите только последние 3 символа `FBFBBFFRLR`:

- Начните с рассмотрения всего диапазона столбцов от `0` до `7`.
- `R` означает взять верхнюю половину, оставив колонки c `4` по `7`.
- `L` означает взять нижнюю половину, оставив колонки с `4` по `5`.
- В финале `R` остается верхний из двух столбцов `5`.

Итак, расшифровка `FBFBBFFRLR` показывает, что это место в `44` ряду, `5` столбце.

У каждого места также есть уникальный идентификатор места: умножьте строку на `8`, затем добавьте столбец. В этом примере у места есть ID. `44 * 8 + 5 = 357`

Вот еще несколько посадочных талонов:

`BFFFBBFRRR`: строка `70`, столбец `7`, идентификатор места `567`.
`FFFBBBFRRR`: строка `14`, столбец `7`, идентификатор места `119`.
`BBFFBBFRLL`: строка `102`, столбец `4`, идентификатор места `820`.
В качестве проверки просмотрите список посадочных талонов. Какой самый высокий идентификатор места в посадочном талоне?

### Решение

Сначала реализуем рекурсивный метод для бинарного поиска в который пеердается список символов и минимальное и максимальное значение. 
Берем символы по одному если 'B' или 'R' увеличиваем минимальное значение, если 'F' | 'L' уменьшаем максимальное на половину разницы между мин и макс.
Рекурсивно вызываем этот же метод убрав первый символ из последовательности, пока минимальное и максимальное значение не уравняются.

Дальше вычисляем строку, столбец и из них идентификатор места. И находим максимальный из них.

## Часть вторая 

Динь! Включились знаки «пристегните ремни безопасности». Пора найти свое место.

Это полностью заполненный рейс, поэтому ваше место должно быть единственным пропущенным посадочным талоном в вашем списке. Однако есть одна загвоздка: некоторых сидений в передней и задней части самолета на этом самолете нет, поэтому они также будут отсутствовать в вашем списке.

Однако ваше место не было ни спереди, ни сзади; места с идентификаторами +1 и -1 из вашего будут в вашем списке.

Какой ID у вашего места?

### Решение

Для поиска пропущеного места сортируем список мест берем по две штуки и ищем те которые отличаются на 2 `prev + 2 = next`, когда находим `prev + 1` является нашим местом.

# День 6: Таможня
## Часть первая
По мере приближения вашего рейса к региональному аэропорту, где вы пересаживаетесь на самолет гораздо большего размера, пассажирам раздают бланки таможенной декларации.

Форма задает ряд 26 да-или-нет вопросов, отмеченных от `a` до `z`. Все, что вам нужно сделать, это определить вопросы, на которые любой член вашей группы отвечает «да». Поскольку ваша группа - это только вы, это не займет много времени.

Однако человек, сидящий рядом с вами, похоже, испытывает языковой барьер, и спрашивает, можете ли вы помочь. Для каждого человека в их группе вы запишите вопросы, на которые они отвечают «да», по одному в каждой строке. Например:
```
abcx
abcy
abcz
```
В этой группе есть 6вопросы , на которые кто ответил «да»: `a`, `b`, `c`, `x`, `y`, и `z`. (Дублирующиеся ответы на один и тот же вопрос не учитываются; каждый вопрос учитывается не более одного раза.)

Другая группа просит вашей помощи, затем другая, и, в конце концов, вы собрали ответы от каждой группы в самолете (ваш ввод головоломки). Ответы каждой группы разделены пустой строкой, и в каждой группе ответы каждого человека находятся в одной строке. Например:
```
abc

a
b
c

ab
ac

a
a
a
a

b
```

В этом списке представлены ответы пяти групп:

- Первая группа состоит из одного человека, который ответил «да» на `3` вопроса: `a`, `b` и `c`.
- Вторая группа состоит из трех человек; в сочетании, они ответили «да» на `3` вопроса: `a`, `b` и `c`.
- Третья группа состоит из двух человек; в сочетании, они ответили «да» на `3` вопроса: `a`, `b` и `c`.
- Четвертая группа состоит из четырех человек; вместе они ответили «да» только на `1` вопрос `a`.
- Последняя группа состоит из одного человека, который ответил «да» только `1` вопрос `b`.

В этом примере сумма этих значений равна `3 + 3 + 3 + 1 + 1` = `11`.

Для каждой группы подсчитайте количество вопросов, на которые кто-нибудь ответил «да». Какова сумма этих подсчетов?

### Решение

Разделяем группы `input.Split("\r\n\r\n")`. Удаляем лишние спец символы `Regex.Replace(group, "\s", "")`. Делаем `distinct` и получаем количество уникальных символов.

## Часть вторая

Когда вы заполняете таможенную декларацию последней группы, вы замечаете, что неправильно прочитали одно слово в инструкции:

Вам не нужно называть вопросы, на которые кто-то ответил «да»; нужно обозначить вопросы, на которые все ответили «да»!

Используя тот же пример, что и выше:
```
abc

a
b
c

ab
ac

a
a
a
a

b
```
В этом списке представлены ответы пяти групп:

- В первой группе, каждый (всего 1 человек) ответили «да» на 3вопросы: `a`, `b` и `c`.
- Во второй группе нет вопросов, на которые все ответили «да».
- В третьей группе, все да ответили только `1` вопрос `a`. Поскольку некоторые люди не ответили «да» на `b` или `c`, они не в счет.
- В четвертой группе, все да ответили только `1` вопрос `a`.
- В пятой группе, каждый (всего 1 человек) ответили «да» на `1` вопрос, `b`.

В этом примере сумма этих значений равна `3 + 0 + 1 + 1 + 1` = `6`.

Для каждой группы подсчитайте количество вопросов, на которые все ответили «да». Какова сумма этих подсчетов?

### Решение

Разделяем группы `input.Split("\r\n\r\n")`. Удаляем лишние спец символы `Regex.Replace(group, "\s", "")`. 
Так как символы в одной строке не повторяются собираем все символы группы в одну строку, считаем количество вхождений каждого символа и оставляем только те, количество которых равно количеству строк.

# День 7: Удобные рюкзаки
## Часть первая

Вы приземляетесь в региональном аэропорту как раз к следующему рейсу. На самом деле, похоже, у вас даже будет время перекусить: в настоящее время все рейсы задерживаются из-за проблем с обработкой багажа.

В связи с недавними авиационными правилами, многие правила (ввод вашей головоломки) вводятся в действие в отношении сумок и их содержимого; сумки должны иметь цветовую маркировку и содержать определенное количество сумок с другой цветной маркировкой. По-видимому, никто, ответственный за эти правила, не думал, сколько времени потребуется на их соблюдение!

Например, рассмотрите следующие правила:

```
light red bags contain 1 bright white bag, 2 muted yellow bags.
dark orange bags contain 3 bright white bags, 4 muted yellow bags.
bright white bags contain 1 shiny gold bag.
muted yellow bags contain 2 shiny gold bags, 9 faded blue bags.
shiny gold bags contain 1 dark olive bag, 2 vibrant plum bags.
dark olive bags contain 3 faded blue bags, 4 dotted black bags.
vibrant plum bags contain 5 faded blue bags, 6 dotted black bags.
faded blue bags contain no other bags.
dotted black bags contain no other bags.
```

Эти правила определяют необходимое содержимое для 9 типов сумок. В этом примере каждый `faded blue` мешок пуст, каждый `vibrant plum` мешок содержит 11 мешков (5 `faded blue` и 6 `dotted black`) и так далее.

У тебя есть `shiny gold` сумка. Если бы вы хотели носить его хотя бы в одной сумке, сколько разных цветов можно было быть до самой внешней сумки? (Другими словами: сколько цветов может в конечном итоге содержать хотя бы одну `shiny gold` сумку?)

В приведенных выше правилах вам будут доступны следующие параметры:

- Сумка `bright white`, которая может содержать вашу `shiny gold` сумку непосредственно.
- Сумка `muted yellow`, которая может содержать вашу `shiny gold` сумку непосредственно, а также некоторые другие пакеты.
- Сумка `dark orange`, которая может содержать `bright white` и `muted yellow` сумки, каждый из которых затем может содержать вашу `shiny gold` сумку.
- Сумка `light red`, которая может содержать `bright white` и `muted yellow` сумки, каждый из которых затем может содержать вашу `shiny gold` сумку.

Итак, в этом примере количество цветов сумок, которые в конечном итоге могут содержать хотя бы одну `shiny gold` сумку, равно `4`.

Сколько цветов сумок может в конечном итоге содержать хотя бы одну `shiny gold` сумку? (Список правил довольно длинный; убедитесь, что вы все усвоили.)

### Решение

Парсим правила в словарь key: цвет сумки, value: массив цветов сумок содержащихся внутри. Рекурсивно ищем в каких сумках содержится нужная нам. Снова вызываем этот метод с только что полученными сумками. 
Убираем дубликаты и получаем нужное значение.

# Часть вторая
В наши дни летать становится довольно дорого - не из-за цен на билеты, а из-за невероятного количества сумок, которые вам нужно купить!

Снова рассмотрим вашу `shiny gold` сумку и правила из приведенного выше примера:

- Сумка `faded blue` содержит `0` других сумок.
- Сумка `dotted black` содержит `0` других сумок.
- Сумка `vibrant plum` содержит `11` других сумок: 5 сумок `faded blue` и 6 `dotted black`.
- Сумка `dark olive` содержит `7` других сумок: 3 сумок `faded blue` и 4 `dotted black`.

Таким образом, один `shiny gold` мешок должен содержать 1 `dark olive` мешок (и 7 мешков внутри него) плюс 2 `vibrant plum` мешка (и по 11 мешков в каждом из них): `1 + 1*7 + 2 + 2*11` = `32` мешки!

Конечно, у настоящих правил есть небольшой шанс пойти на несколько уровней глубже, чем в этом примере; обязательно пересчитайте все сумки, даже если размещение становится топологически непрактичным!

Вот еще один пример:
```
shiny gold bags contain 2 dark red bags.
dark red bags contain 2 dark orange bags.
dark orange bags contain 2 dark yellow bags.
dark yellow bags contain 2 dark green bags.
dark green bags contain 2 dark blue bags.
dark blue bags contain 2 dark violet bags.
dark violet bags contain no other bags.
```

В этом примере одна `shiny gold` сумка должна содержать `126` другие сумок.

Сколько отдельных сумок требуется внутри вашей единственной `shiny gold` сумки?

### Решение

Парсим правила в словарь key: цвет сумки, value: массив цветов сумок и их количества содержащихся внутри. Рекурсивно считаем количество сомок внутри. 
Количество сумок внутри прибавляем к количеству сумок внутри каждой из них умноженной на её количество.

# День 8: Ручная остановка
## Часть первая
Ваш рейс до крупного авиаузла достигает крейсерской высоты без происшествий. Пока вы подумываете проверить в бортовом меню один из тех напитков, которые идут с маленьким зонтиком, вас прерывает ребенок, сидящий рядом с вами.

Их портативная игровая консоль не включается! Они спрашивают, можно ли взглянуть.

Вы сужаете проблему до странного бесконечного цикла в загрузочном коде (вводе головоломки) устройства. У вас должно получиться исправить это, но сначала вам нужно иметь возможность запускать код изолированно.

Загрузочный код представлен в виде текстового файла с одной инструкцией на строку текста. Каждая инструкция состоит из операции (`acc`, `jmp` или `nop`) и аргумента (числа со знаком, например `+4` или `-20`).

- `acc` увеличивает или уменьшает единичное глобальное значение, называемое аккумулятором , на значение, указанное в аргументе. Например, `acc +7` увеличил бы аккумулятор на 7. Аккумулятор начинается с `0`. После `acc` инструкции выполняется инструкция, находящаяся непосредственно под ней.
- `jmp` переходит к новой инструкции относительно себя. Следующая инструкция для выполнения находится с использованием аргумента как смещения от `jmp` инструкции; например, `jmp +2` пропустит следующую инструкцию, `jmp +1` перейдет к инструкции, находящейся непосредственно под ней, и `jmp -20` вызовет выполнение следующей инструкции на 20 строк выше.
- `nop` расшифровывается как No OPeration - ничего не делает. Далее выполняется инструкция, расположенная непосредственно под ним.

Например, рассмотрим следующую программу:
```
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
```

Эти инструкции просматриваются в следующем порядке:

```
nop +0  | 1
acc +1  | 2, 8(!)
jmp +4  | 3
acc +3  | 6
jmp -3  | 7
acc -99 |
acc +1  | 4
jmp -4  | 5
acc +6  |
```
Во-первых, `nop +0` ничего не делает. Затем аккумулятор увеличивается с 0 до 1 (`acc +1`) и `jmp +4` устанавливает следующую инструкцию для другой `acc +1` в нижней части. После того, как он увеличивает аккумулятор с 1 до 2, `jmp -4` выполняется, устанавливая для следующей инструкции единственную `acc +3`. Он устанавливает аккумулятор на 5 и `jmp -3` заставляет программу продолжить с первого `acc +1`.

Это бесконечный цикл : с этой последовательностью переходов программа будет работать вечно. В тот момент, когда программа пытается выполнить какую-либо инструкцию во второй раз, вы знаете, что она никогда не завершится.

Непосредственно перед тем, как программа выполнит инструкцию во второй раз, значение в аккумуляторе равно `5`.

Запустите вашу копию загрузочного кода. Какое значение находится в аккумуляторе непосредственно перед выполнением любой инструкции во второй раз?

### Решение

Парсим входные данные в массив кортежей (операция, аргумент). 
Для для выполнения одной операции воспользуемся методом:
```
let step (act, arg) i acc =
    match act with
    | "acc" ->(i+1, acc+arg) 
    | "jmp" -> (i+arg, acc) 
    | _ -> (i+1, acc)
```
Который принимает на вход кортеж с операцией `(act, arg)` индекс текущей строки `i` и аккумулятор `acc`. 
В зависимости от операции меняем индекс и аккумулятор и возвращаем их.

Выполняем инструкции пошагово сохраняя индексы посещенных строк и если встречаем повторение возвращаем аккумулятор.

## Часть вторая

После тщательного анализа вы считаете, что повреждена ровно одна инструкция.

Где - то в программе, либо `jmp` должно быть `nop`, или `nop` должен быть `jmp`. (Никакие `acc` инструкции не пострадали в результате повреждения этого загрузочного кода.)

Предполагается, что программа завершится попыткой выполнить инструкцию сразу после последней инструкции в файле. Изменив ровно один `jmp` или `nop`, вы можете исправить загрузочный код и заставить его правильно завершить работу.

Например, рассмотрим ту же программу сверху:

```
nop +0
acc +1
jmp +4
acc +3
jmp -3
acc -99
acc +1
jmp -4
acc +6
```

Если вы измените первую инструкцию с `nop +0` на `jmp +0`, это создаст бесконечный цикл с одной инструкцией, никогда не покидая эту инструкцию. Если вы измените почти любую из `jmp` инструкций, программа все равно найдет другую `jmp` инструкцию и цикл навсегда.

Однако, если вы измените предпоследнюю инструкцию (с `jmp -4` на `nop -4`), программа завершится! Инструкции просматриваются в таком порядке:

```
nop +0  | 1
acc +1  | 2
jmp +4  | 3
acc +3  |
jmp -3  |
acc -99 |
acc +1  | 4
nop -4  | 5
acc +6  | 6
```
После последней инструкции (`acc +6`) программа завершается попыткой выполнить инструкцию под последней инструкцией в файле. С этим изменением, после того, как программа завершается, аккумулятор содержит значение `8` (`acc +1`, `acc +1`, `acc +6`).

Исправьте программу так, чтобы она завершалась нормально, изменив ровно один `jmp`(на `nop`) или `nop`(на `jmp`). Какое значение имеет аккумулятор после завершения программы?

### Решение

Для замены инструкций используем метод для доступа к элементам массива. Который принимает на вход массив действий, индекс при котором заменяются инструкции и индекс элемента который хотим получить.

```
let getItem (sourse: (string*int)[]) changeInd i =    
    if i >= sourse.Length then 
        None
    else
        let (act, arg) = sourse.[i]
        match (act, changeInd = i) with
        | "nop", true -> Some("jmp", arg)
        | "jmp", true -> Some("nop", arg)
        | _, _ -> Some(act, arg)
```

Если индекс выходит за границе массива возвращаем `None`, иначе инструкцию. 
Что поможет получать измененные значения без изменения исходного массива или создания копии массива с одним измененным значением.
Этот же метод можно использовать для первой части указав индекс для изменения не встречающийся в массиве например -1.

Для нахождения операции которую необходимо заменить воспользуемся перебором, будем заменять операции по одной пока все инструкции не выполнятся.
Для этого используем рекурсивным методом. На каждой итерации увеличиваем `changeInd` из метода `getItem` и выполняем инструкции. 

```
let rec findOutOfInstruction i =
    let (ind, acc) = calcInstruction (getItem instruction i)
    if ind >= instruction.Length then acc
    else findOutOfInstruction (i+1)
```

Смотрим на каком индексе заканчивается выполнение если индекс больше длины массива с инструкциями значит инструкции выполнились до конца.
Если индекс меньше длины массива увеличиваем индекс операции для замены и пытаемся снова.

# День 9: Ошибка кодирования
# Часть первая

Когда ваш сосед радостно наслаждается своей видеоигрой, вы обращаете внимание на открытый порт данных на маленьком экране на сиденье перед вами.

Хотя порт нестандартный, вам удается подключить его к компьютеру, используя несколько скрепок. После подключения порт выводит серию чисел (ввод вашей головоломки).

Данные, по-видимому, зашифрованы с помощью системы добавления маскировки обмена (XMAS), которая, к вашему удобству, является старым шифром с серьезным недостатком.

XMAS начинается с передачи преамбулы из 25 чисел. После этого каждое полученное вами число должно быть суммой любых двух из 25 непосредственно предшествующих чисел. Два числа будут иметь разные значения, и таких пар может быть несколько.

Например, предположим, что ваша преамбула состоит из цифр от `1` до `25` в случайном порядке. Чтобы быть действительным, следующее число должно быть суммой двух из этих чисел:

- `26` будет действительным следующим числом, так как это может быть `1` плюс `25` (или многие другие пары, например `2` и `24`).
- `49` будет допустимым следующим числом, так как это сумма `24` и `25`.
- `100` будет не действителен; никакие два из предыдущих 25 чисел не суммируются в 100.
- `50` тоже не будет действительным; хотя `25` встречается в предыдущих 25 числах, два числа в паре должны быть разными.

Предположим, 26-е число есть `45`, а первое число (теперь не используется, так как это было более 25 чисел назад) было `20`. Теперь, чтобы следующее число было действительным, должна быть какая-то пара чисел среди `1` - `19`, `21` - `25` или `45` которые складываются в него:

- `26` будет по-прежнему действительным следующим числом, как `1` и `25` входят в предыдущие 25 чисел.
- `65` будет не действительным, а не два из доступных номеров не подводить к нему.
- `64` и `66` оба будут действительными, поскольку они являются результатом `19+45` и `21+45` соответственно.

Вот более крупный пример, который учитывает только предыдущие 5 чисел (и имеет преамбулу длиной 5):
```
35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576
```

В этом примере после преамбулы из 5 чисел почти каждое число является суммой двух из предыдущих 5 чисел; единственное число, которое не следует этому правилу - `127`.

Первый шаг атаки на слабые места в данных XMAS - найти первое число в списке (после преамбулы), которое не является суммой двух из 25 чисел перед ним. Какое первое число не имеет этого свойства?

### Решение

Начинае с функции определяющей содержится ли в списке пару чисел которые в сумме дают нужное число.
```fsharp
let isExistSum sourse sum = 
    Seq.allPairs sourse sourse |> Seq.where (fun (f,s) -> f <> s) |> Seq.exists (fun (f,s) -> f+s = sum)
```
Функция `Seq.allPairs` возвращает последовательность содержащую все пары элементов из первой и второй последовательностей. Передаем в неё дважды наш список и получаем все возможные комбинации из элеменгов списка.
Убираем те из них в торорых значения совпадают. И проверяем есть ли такая пара чисел что даст требуемую сумму.

Далее рекурсивно ищем не действительный элемент. Метод принимает список чисел и длину преамбулы.
```fsharp
let rec findNotValid sourse step =
    if isExistSum (List.take step sourse) (sourse.[step]) then
        findNotValid (List.tail sourse) step
    else
        sourse.[step]
```
В функцию isExistSum передаем первые 25 элементов из списка и 26 элемент как требуемую сумму. Если число действительное убираем первый элемент из списка и пробуем снова.
Когда находи не действительный элемент это и будет наш ответ.

## Часть вторая

Последний шаг в взломе шифрования XMAS основан на неверном номере, который вы только что нашли: вы должны найти непрерывный набор по крайней мере из двух чисел в своем списке, которые суммируются в недопустимое число из шага 1.

Снова рассмотрим приведенный выше пример:
```
35
20
15
25
47
40
62
55
65
95
102
117
150
182
127
219
299
277
309
576
```

В этом списке сложение всех чисел от `15` до `40` дает недопустимое число с шага 1 `127`. (Конечно, непрерывный набор чисел в вашем фактическом списке может быть намного длиннее.)

Чтобы найти уязвимость шифрования, сложите наименьшее и наибольшее число в этом непрерывном диапазоне; в этом примере это `15` и `47`, производящие `62`.

В чем заключается слабость шифрования в вашем зашифрованном XMAS списке номеров?

### Решение

Ищем непрерывный набор элементов, сумма которых равна значению из части 1.
```fsharp
let rec findContiguousSet sourse (sum: int64) acc =    
    if List.sum acc = sum then
        acc
    else
        let res = List.head sourse :: acc
        findContiguousSet (List.tail sourse) sum (removeLastUntilMoreSum sum res)
```
Берем первый элемент списка и добавляем к аккумулятору (изначально пустой список) если сумма элементов больше искомой суммы удаляем последние элементы пока сумма не станет меньше.
И повторяем снова убрав первый элемент из списка пока не наедем нужную последовательность.

Найдя требуемую непрерывную последовательность для вычисления уязвимости шифрования находим минимальный и максимальный элемент и складываем.
```fsharp
List.min set + List.max set
```

# День 10: Массив адаптеров
# Часть первая

Войдя в порт данных самолета, вы получаете прогноз погоды о сильном тропическом шторме. Однако прежде чем вы сможете понять, повлияет ли это на ваши планы на отпуск, ваше устройство внезапно отключается!

Его батарея разряжена.

Вам нужно будет подключить его к розетке. Есть только одна проблема: зарядная розетка рядом с вашим сиденьем производит неправильное напряжение. Вы всегда готовы составить список всех переходников в своей сумке.

Каждый из ваших адаптеров напряжения рассчитан на определенное выходное напряжение (вход вашей головоломки). Любой данный адаптер может воспринимать входное напряжение `1`, `2` или `3` вольта ниже своих номинальных значений, но при этом производить номинальные выходные напряжения.

Кроме того, в вашем устройстве есть встроенный адаптер, рассчитанный на 3 вольта больше, чем у адаптера с самым высоким номиналом в вашей сумке. (Если бы в вашем списке адаптеров были `3`, `9` и `6`, встроенный адаптер вашего устройства был бы рассчитан на `12` вольт.)

Относитесь к розетке для зарядки рядом с вашим сиденьем как к имеющую эффективное номинальное напряжение `0`.

Поскольку у вас есть время, вы можете протестировать все свои адаптеры. Не хотелось бы попасть на курорт и понять, что вы даже не можете зарядить свое устройство!

Если вы используете все адаптеры в сумке одновременно, каково распределение разницы в напряжении между зарядной розеткой, адаптерами и вашим устройством?

Например, предположим, что у вас в сумке есть адаптеры со следующими номинальными нагрузками:
```
16
10
15
5
1
11
7
19
6
12
4
```

С этими адаптерами встроенный адаптер напряжения вашего устройства будет рассчитан на `19 + 3` = `22` вольта, что на 3 выше, чем у адаптера с самым высоким номиналом.

Поскольку адаптеры могут подключаться к источнику только на 1-3 вольта ниже его номинала, для использования каждого адаптера вам необходимо выбрать их следующим образом:

- Зарядная розетка имеет эффективный номинал `0` вольт, поэтому единственные адаптеры, которые могут подключаться к ней напрямую, должны иметь номинальное напряжение `1`, `2` или `3` вольта. Из них только один - адаптер на `1` вольт (разница в 1).
- Из адаптера с номиналом `1` вольт единственный выбор - адаптер с номиналом `4` вольта (разница в 3).
- Из адаптера с номиналом `4` вольта можно выбрать адаптеры с номиналом `5`, `6` или `7`. Однако, чтобы не пропустить ни одного адаптера, вы должны выбрать адаптер на `5` вольт (разница в 1).
- Точно так же следующим выбором будет адаптер с номиналом `6`, а затем адаптер с номиналом `7` (с разницей в 1 и 1).
- Единственный адаптер, который работает с адаптером на `7` вольт, - это адаптер на `10` вольт (разница в 3).
- Из `10` можно выбрать `11` или `12`; выберите `11` (разница в 1), а затем `12` (разница в 1).
- После `12` только адаптер имеющий номинал `15` (разница в 3), затем `16` (разница в 1), затем `19` (разница в 3).
- Наконец, встроенный адаптер вашего устройства всегда на 3 больше, чем самый высокий адаптер, поэтому его номинал составляет `22` вольта (всегда разница в 3).

В этом примере при использовании каждого адаптера имеется `7` разностей по 1 вольту и `5` разностей по 3 вольта.

Вот более крупный пример:
```
28
33
18
42
31
14
46
20
48
47
24
23
49
45
19
38
39
11
1
32
25
35
8
17
7
9
4
2
34
10
3
```

В этом более крупном примере в цепи, в которой используются все адаптеры, есть `22` разности по 1 вольту и `10` разностей по 3 вольта.

Найдите цепь, которая использует все ваши адаптеры для подключения зарядной розетки к встроенному адаптеру вашего устройства, и посчитайте разницу напряжений между зарядной розеткой, адаптерами и вашим устройством. Какое количество разностей в `1` вольт умноженных на количество разностей в `3` вольта?

### Решение

Для получения полного списка переходов добавляем к исходным данным 0 и максимальный элемент + 3.
Сортируем коллекцию по возрастанию и приходимся по ней беря по два соседних элемента и находя разницу между ними. 
Так мы получим список разниц напряжения между всеми адаптерами.
Остается только посчитать количество разниц в 1 и 3, а потом перемножить.

## Часть вторая
Чтобы полностью определить, достаточно ли у вас адаптеров, вам нужно выяснить, сколькими различными способами они могут быть расположены. 
Каждое способ должен подключать зарядную розетку к вашему устройству. 
Предыдущие правила о том, когда адаптеры могут успешно подключаться, по-прежнему применяются.

Первый пример выше (тот, который начинается с `16`, `10`, `15`) поддерживает следующие способы:

```
(0), 1, 4, 5, 6, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 6, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 5, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 6, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 6, 7, 10, 12, 15, 16, 19, (22)
(0), 1, 4, 7, 10, 11, 12, 15, 16, 19, (22)
(0), 1, 4, 7, 10, 12, 15, 16, 19, (22)
```

(Зарядная розетка и встроенный адаптер вашего устройства показаны в скобках.) 
Учитывая адаптеры из первого примера, общее количество устройств, которые подключают зарядную розетку к вашему устройству, составляет `8`.

Второй пример выше (тот , который начинается с `28`, `33`, `18`) имеет много вариантов компоновки адаптеров. Вот несколько:

```
(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31,
32, 33, 34, 35, 38, 39, 42, 45, 46, 47, 48, 49, (52)

(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31,
32, 33, 34, 35, 38, 39, 42, 45, 46, 47, 49, (52)

(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31,
32, 33, 34, 35, 38, 39, 42, 45, 46, 48, 49, (52)

(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31,
32, 33, 34, 35, 38, 39, 42, 45, 46, 49, (52)

(0), 1, 2, 3, 4, 7, 8, 9, 10, 11, 14, 17, 18, 19, 20, 23, 24, 25, 28, 31,
32, 33, 34, 35, 38, 39, 42, 45, 47, 48, 49, (52)

(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45,
46, 48, 49, (52)

(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45,
46, 49, (52)

(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45,
47, 48, 49, (52)

(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45,
47, 49, (52)

(0), 3, 4, 7, 10, 11, 14, 17, 20, 23, 25, 28, 31, 34, 35, 38, 39, 42, 45,
48, 49, (52)
```

В целом, этот набор адаптеров может подключать зарядную розетку к вашему устройству `19208` различными способами.

Вы снова смотрите на свою сумку и пытаетесь вспомнить, зачем вы взяли с собой столько адаптеров; должно быть более триллиона действенных способов их устроить! Конечно, должен быть эффективный способ подсчета аранжировок.

Каково общее количество различных способов расположения адаптеров для подключения зарядной розетки к вашему устройству?

### Решение

Так как вариантов компоновки адаптеров очень много мы не можем решить эту задачу простым переборов всех вариантов.
Поэтому будем искать закономерности.

Для начала посчитаем сколько вариантов компоновки имеет каждый адаптер.

Как и в первой части добавляем 0 и max+3 и сортируем. Далее для каждого адаптера ищем адаптеры к которым можем подключиться с разницей от `1` до `3`.
```fsharp
let findAdapters sourse adapter =
    List.where (fun x -> x > adapter && x <= adapter+3) sourse 
```

Затем считаем количество вариантов для каждого адаптера.

```fsharp
let mapAdaptersInVariants sourse = 
     sourse |> List.sort |> List.map (fun x -> findAdapters sourse x |> List.length)    
```

Получаем последовательность вида (здесь из примера 2)
`3; 3; 2; 1; 1; 3; 3; 2; 1;  1;  1;  3;  2;  1;  1;  2;  1;  1;  1;  3;  3;  2;  1;  1;  1;  1;  1;  3;  3;  2;  1;  1;  0`
`0; 1; 2; 3; 4; 7; 8; 9; 10; 11; 14; 17; 18; 19; 20; 23; 24; 25; 28; 31; 32; 33; 34; 35; 38; 39; 42; 45; 46; 47; 48; 49; 52`
`3; 3; 2; 1; 1; 3; 3; 2; 1; 1; 1; 3; 2; 1; 1; 2; 1; 1; 1; 3; 3; 2; 1; 1; 1; 1; 1; 3; 3; 2; 1; 1; 0`

Мы не можем просто перемножить варианты, так как они пересекаются друг с другом. 
С последовательностью `2; 1; 1` все нормально она содержит 2 варианта
Рассмотрим последовательность `3; 2; 1; 1`. `3` означает что у нас есть `3` варианта, т.е. мы можем перейти на `2`, `1` или `1`. 
Посмотрим на возможные варианты
`3; 2; 1; 1`   Последовательность `2; 1; 1` мы уже рассмотрели она содержит `2` варианта перехода
`3; 1; 1`      Один вариант перехода
`3; 1`         И один вариант перехода

Складываем из вместе и получаем для последовательности `3; 2; 1; 1` `4` варианта перехода.

Последовательность `3; 3; 2; 1; 1`, включает предыдущее.
`3; 2; 1; 1` -> `4` варианта
`2; 1; 1` -> `2` варианта
`1; 1` -> `1` вариант
Итого последовательность `3; 3; 2; 1; 1` содержит `7` вариантов перехода.

Остается только посчитать варианты в последовательностях и перемножить их.

```fsharp
let rec countWays sourse i = 
    match sourse with
    | 3 :: 3 :: 2 :: 1 :: 1 :: tail -> countWays tail (i * 7L)
    | 3 :: 2 :: 1 :: 1 :: tail -> countWays tail (i * 4L)
    | 2 :: 1 :: 1 :: tail -> countWays tail (i * 2L)
    | 1 :: tail -> countWays tail i
    | _ -> i
```

# День 11: Система рассадки
## Часть первая 

Ваш самолет приземляется с большим запасом времени. Заключительный этап вашего путешествия - паром, который идет прямо на тропический остров, где вы, наконец, можете начать свой отпуск. Добравшись до места ожидания, чтобы сесть на паром, вы понимаете, что вы так рано, что никто еще даже не прибыл!

Моделируя процесс, который люди используют для выбора (или отказа) своего места в зоне ожидания, вы почти уверены, что сможете предсказать лучшее место для сидения. Вы быстро составляете карту расположения сидений (входная информация для вашей головоломки).

Расположение сидений аккуратно укладывается в сетку. Каждая позиция - это пол (`.`), свободное место (`L`) или занятое место (`#`). Например, первоначальная компоновка сидений может выглядеть так:
```
L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
```

Теперь вам просто нужно смоделировать людей, которые скоро появятся. К счастью, люди полностью предсказуемы и всегда следуют простому набору правил. Все решения основываются на количестве занятых сидений, смежных с данным сиденьем (одно из восьми положений, расположенных непосредственно вверх, вниз, влево, вправо или по диагонали от сиденья). Следующие правила применяются одновременно к каждому месту:

- Если место пусто (`L`) и рядом с ним нет занятых мест, оно становится занятым.
- Если сиденье занято (`#`) и четыре или более соседних с ним сиденья также заняты, сиденье становится пустым.
- В противном случае состояние сиденья не меняется.

Пол (`.`) никогда не меняется; сиденья не двигаются, и никто не сидит на полу.

После одного раунда выполнения этих правил каждое место в примере компоновки становится занятым:
```
#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##
```

После второго тура места с четырьмя или более занятыми соседними местами снова становятся пустыми:
```
#.LL.L#.##
#LLLLLL.L#
L.L.L..L..
#LLL.LL.L#
#.LL.LL.LL
#.LLLL#.##
..L.L.....
#LLLLLLLL#
#.LLLLLL.L
#.#LLLL.##
```

Этот процесс продолжается еще три раунда:
```
#.##.L#.##
#L###LL.L#
L.#.#..#..
#L##.##.L#
#.##.LL.LL
#.###L#.##
..#.#.....
#L######L#
#.LL###L.L
#.#L###.##
```

```
#.#L.L#.##
#LLL#LL.L#
L.L.L..#..
#LLL.##.L#
#.LL.LL.LL
#.LL#L#.##
..L.L.....
#L#LLLL#L#
#.LLLLLL.L
#.#L#L#.##
```

```
#.#L.L#.##
#LLL#LL.L#
L.#.L..#..
#L##.##.L#
#.#L.LL.LL
#.#L#L#.##
..L.L.....
#L#L##L#L#
#.LLLLLL.L
#.#L#L#.##
```
В этот момент происходит кое-что интересное: хаос стабилизируется, и дальнейшее применение этих правил не приводит к изменению состояния сидений! Когда люди перестают двигаться, вы учитываете `37` занятых мест.

Смоделируйте место для сидения, многократно применяя правила рассадки, пока ни одно из мест не изменится. Сколько мест в итоге занято?

### Решение

Что-бы найти соседние места нужно обращаться к элементам по координатам.
```fsharp
let getItem (map: string list) x y = 
    if x < 0 || y < 0 || x >= map.Head.Length || y >= map.Length then '.'
    else map.[y].[x]
```

Находим количество соседей со смещением {1,1;0,1;-1,1;..} и т.д. изменяем состояние места в зависимости от количества соседей.
После того как просмотри все места сверяем с местами из пердидущего шага, и если нет изменений считаем занятые места.

## Часть вторая
Как только люди начинают приходить, вы понимаете свою ошибку. Людей волнуют не только соседние места - они заботятся о том, какое первое место они увидят в каждом из этих восьми направлений!

Теперь, вместо того, чтобы рассматривать только восемь непосредственно соседних мест, рассмотрите первое место в каждом из этих восьми направлений. Например, на пустом месте ниже будет восемь занятых мест:
```
.......#.
...#.....
.#.......
.........
..#L....#
....#....
.........
#........
...#.....
```
Крайнее левое свободное место ниже будет видеть только одно свободное место, но не может видеть ни одно из занятых:
```
.............
.L.L.#.#.#.#.
.............
```

Пустое место внизу не увидел бы не занимали места:
```
.##.##.
#.#.#.#
##...##
...L...
##...##
#.#.#.#
.##.##.
```

Кроме того, люди кажутся более терпимыми, чем вы ожидали: теперь требуется пять или более видимых занятых мест, чтобы занятое место стало пустым (а не четыре или более из предыдущих правил). Остальные правила остаются в силе: пустые места, на которых нет занятых мест, становятся занятыми, места, не соответствующие правилам, не меняются, а пол никогда не меняется.

Учитывая ту же начальную планировку, что и выше, эти новые правила заставляют зону отдыха перемещаться следующим образом:
```
L.LL.LL.LL
LLLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLLL
L.LLLLLL.L
L.LLLLL.LL
```

```
#.##.##.##
#######.##
#.#.#..#..
####.##.##
#.##.##.##
#.#####.##
..#.#.....
##########
#.######.#
#.#####.##
```

```
#.LL.LL.L#
#LLLLLL.LL
L.L.L..L..
LLLL.LL.LL
L.LL.LL.LL
L.LLLLL.LL
..L.L.....
LLLLLLLLL#
#.LLLLLL.L
#.LLLLL.L#
```

```
#.L#.##.L#
#L#####.LL
L.#.#..#..
##L#.##.##
#.##.#L.##
#.#####.#L
..#.#.....
LLL####LL#
#.L#####.L
#.L####.L#
```

```
#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##LL.LL.L#
L.LL.LL.L#
#.LLLLL.LL
..L.L.....
LLLLLLLLL#
#.LLLLL#.L
#.L#LL#.L#
```

```
#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##L#.#L.L#
L.L#.#L.L#
#.L####.LL
..#.#.....
LLL###LLL#
#.LLLLL#.L
#.L#LL#.L#
```

```
#.L#.L#.L#
#LLLLLL.LL
L.L.L..#..
##L#.#L.L#
L.L#.LL.L#
#.LLLL#.LL
..#.L.....
LLL###LLL#
#.LLLLL#.L
#.L#LL#.L#
```
Опять же, в этот момент люди перестают двигаться, и зона отдыха достигает равновесия. Как только это произойдет, вы подсчитываете `26` занятых мест.

С учетом нового метода видимости и изменения правила, согласно которому занятые места становятся пустыми, после достижения равновесия сколько мест в конечном итоге оказывается занятым?

### Решение

Решение аналогично первой части только заменяем метод поиска соседей.
```fsharp
let getNeighborDir (map:string list) x y offssetX offsetY = 
    let rec getItemDir x y =
        match getItem map x y with
        | '.' -> getItemDir (offssetX+x) (offsetY+y)
        | char -> char
    getItemDir (offssetX+x) (offsetY+y)
```

# День 12: Риск дождя
# Часть первая

Ваш паром прилично продвинулся к острову, но шторм пришел быстрее, чем кто-либо ожидал . Паром должен действовать уклончиво !

К сожалению, судовой навигационный компьютер, похоже, неисправен; вместо того, чтобы указывать путь непосредственно к безопасности, он давал чрезвычайно окольные инструкции. Когда капитан использует систему громкой связи, чтобы спросить, может ли кто-нибудь помочь, вы быстро становитесь волонтером.

Инструкции по навигации (входные данные для головоломки) состоят из последовательности действий, состоящих из одного символа, в сочетании с целочисленными входными значениями . Посмотрев на них несколько минут, вы поймете, что они, вероятно, означают:

- Действие `N` означает движение на север на заданное значение.
- Действие `S` означает движение на юг на заданное значение.
- Действие `E` означает движение на восток на заданное значение.
- Действие `W` означает движение на запад на заданное значение.
- Действие `L` означает поворот влево на заданное количество градусов.
- Действие `R` означает поворот вправо на заданное количество градусов.
- Действие `F` означает движение вперед на заданное значение в направлении, в котором в данный момент смотрит корабль.

Корабль начинается с востока. Только `L` и `R` действия меняют направление корабля. 
(То есть, если корабль смотрит на восток и следующая инструкция гласит `N10`, что корабль двинется на `10` единиц на север, но все равно двинется на восток, если будет выполнено следующее действие `F`.)

Например:
```
F10
N3
F7
R90
F11
```

Эти инструкции будут обрабатываться следующим образом:

- `F10` переместит корабль на 10 единиц на восток (потому что корабль начинает с востока) [восток 10, север 0].
- `N3` переместит корабль на 3 единицы на север [восток 10, север 3].
- `F7` переместит корабль еще на 7 единиц на восток (потому что корабль все еще смотрит на восток) [восток 17, север 3].
- `R90` заставит корабль повернуть направо на 90 градусов и повернуть лицом на юг; он остается на [восток 17, север 3].
- `F11` переместит корабль на 11 единиц на юг [восток 17, юг 8].

В конце этих инструкций манхэттенское расстояние корабля (сумма абсолютных значений его положения восток/запад и положения север/юг) от его исходного положения равно `17 + 8= 25`.

Выясните, куда ведут инструкции по навигации. Какое манхэттенское расстояние между этим местом и стартовой позицией корабля?

### Решение

Для хранения положения и направления корабля будем использовать запись.

```fsharp
type vector2 = {x:int; y:int}
```

В задаче имеется 2 вида действий движение и поворот.
Для движения будем складывать два вектора.
```fsharp
let sumVector v1 v2 = {x = v1.x+v2.x; y = v1.y+v2.y}
```

Все повоторы корабля кратны 90 градусам. Поворот вектора на 90 градусов вычисляется по формуле `{ x=y; y=-x }`. 
Для поворота против часовой стрелки в функцию передается отрицательный угол чтобы получить положительный добавим к углу поворота 360, например: `-90 + 360 = 270`.
Делим получившийся угол на 90, что-бы узнать сколько раз нужно повернуть на 90 градусов. Поворачиваем вектор нужное количество раз. 

```fsharp
let rotateVector (vector:vector2) (angle:int) = 
    [|1..(angle+360)/90|] |> Array.fold (fun d _ -> {x = d.y; y=(-d.x)}) vector
```

Функция выполнения одной команды принимает в себя кортеж (направление * положение) и кортеж команды. 
Возвращает кортеж (направление * положение), что позволяет легко подать этот кортеж обратно на вход.
```fsharp
let step ((dir:vector2),(pos:vector2)) (key, value) =
    match key with
    | 'N' -> (dir, sumVector pos {x=0; y=value})
    | 'S' -> (dir, sumVector pos {x=0; y=(-value)})
    | 'E' -> (dir, sumVector pos {x=value; y=0})
    | 'W' -> (dir, sumVector pos {x=(-value); y= 0})
    | 'L' -> (rotateVector dir -value, pos)
    | 'R' -> (rotateVector dir value, pos)
    | 'F' -> (dir, sumVector pos {x=dir.x*value; y=dir.y*value})
```

Выполняем этот метод со всеми входными коммандами и получаем итоговую позицию. Для нахождения манхэттенского расстояние складываем модули `x` и `y`.

# Часть вторая
Прежде чем вы сможете сообщить место назначения капитану, вы понимаете, что фактические значения действий все время были напечатаны на обратной стороне инструкций.

Почти все действия указывают, как переместить путевую точку относительно положения корабля:

- Действие `N` означает перемещение путевой точки на север на заданное значение.
- Действие `S` означает перемещение путевой точки на юг на заданное значение.
- Действие `E` означает перемещение путевой точки на восток на заданное значение.
- Действие `W` означает перемещение путевой точки на запад на заданное значение.
- Действие `L` означает поворот путевой точки вокруг корабля влево (против часовой стрелки) на заданное количество градусов.
- Действие `R` означает поворот путевой точки вокруг корабля вправо (по часовой стрелке) на заданное количество градусов.
- Действие `F` означает перемещения корабля вперед к путевой точке число раз, равное заданному значению.

Путевая точка начинается на 10 единиц к востоку и на 1 север относительно корабля. Путевая точка указывается относительно корабля; то есть, если корабль движется, путевая точка перемещается вместе с ним.

Например, используя те же инструкции, что и выше:

- `F10` перемещает корабль к путевой точке 10 раз (всего 100 единиц на восток и 10 единиц на север ), оставляя корабль на [восток 100, север 10]. Путевая точка находится в 10 единицах к востоку и 1 к северу от корабля.
- `N3` перемещает путевую точку на 3 единицы к северу, на 10 единиц к востоку и на 4 единицы к северу от корабля. Корабль остается на [восток 100, север 10].
- `F7` перемещает корабль к путевой точке 7 раз (всего 70 единиц к востоку и 28 единиц к северу ), оставляя корабль на [восток 170, север 38]. Путевая точка находится в 10 единицах к востоку и в 4 единицах к северу от корабля.
- `R90` поворачивает путевую точку вокруг корабля по часовой стрелке на 90 градусов, перемещая ее на 4 единицы к востоку и на 10 единиц к югу от корабля. Корабль остается на [восток 170, север 38].
- `F11` перемещает корабль к путевой точке 11 раз (всего 44 единицы на восток и 110 единиц на юг), оставляя корабль на [восток 214, юг 72]. Путевая точка находится на 4 единицы к востоку и на 10 единиц к югу от корабля.

После этих операций манхэттенское расстояние корабля от его начальной позиции равно `214 + 72= 286`.

Выясните, куда на самом деле ведут инструкции по навигации. Какое манхэттенское расстояние между этим местом и стартовой позицией корабля?

### Решение

Решение аналогично первой части только вместо вектора направления используется вектор положения путевой точки.

```fsharp
let step2 ((waypoint:vector2),(pos:vector2)) (key, value) =
    match key with
    | 'N' -> (sumVector waypoint {x=0; y=value}, pos)
    | 'S' -> (sumVector waypoint {x=0; y=(-value)}, pos)
    | 'E' -> (sumVector waypoint {x=value; y=0}, pos)
    | 'W' -> (sumVector waypoint {x=(-value); y=0}, pos)
    | 'L' -> (rotateVector waypoint -value, pos)
    | 'R' -> (rotateVector waypoint value, pos)
    | 'F' -> (waypoint, sumVector pos {x=waypoint.x * value; y=waypoint.y * value})
 ```
# День 13: Поиск автобуса
## Часть первая 

Ваш паром может благополучно добраться до ближайшего порта, но дальше он не продвинется. Когда вы звоните, чтобы забронировать другой корабль, вы обнаруживаете, что ни один корабль не отправляется из этого порта на ваш остров для отдыха. Вам нужно будет добраться из порта до ближайшего аэропорта.

К счастью, из морского порта в аэропорт можно добраться на автобусе-шаттле! У каждого автобуса есть идентификационный номер, который также указывает, как часто автобус отправляется в аэропорт.

Расписание автобусов определяется на основе метки времени, которая измеряет количество минут с момента некоторой фиксированной контрольной точки в прошлом. По отметке времени `0` все автобусы одновременно отправились из морского порта. После этого каждый автобус едет в аэропорт, затем в другие места и, наконец, возвращается в морской порт, чтобы навсегда повторить свое путешествие.

Временной цикл конкретного автобуса такой же как его идентификационный номер: автобус с ID `5` отходит от морского порта в `0, 5, 10, 15`, и так далее. Автобус с ID `11` отправляется в `0, 11, 22, 33`, и так далее. Если вы будете там, когда автобус отправится, вы можете поехать на этом автобусе в аэропорт!

Ваши заметки (ввод головоломки) состоят из двух строк. Первая строка - это ваша оценка самой раннего времени, когда вы могли бы уехать на автобусе. Во второй строке перечислены идентификаторы автобусов, которые обслуживаются согласно данным транспортной компании; записи, которые отображаются, `x` не обслуживаются, поэтому вы решили их игнорировать.

Чтобы сэкономить время по прибытии, ваша цель - найти ближайший автобус, на котором вы сможете добраться до аэропорта. (Такой автобус будет ровно один.)

Например, предположим, что у вас есть следующие заметки:
```
939
7,13,x,x,59,x,31,19
```

Здесь самое раннее время когда вы могли бы отправиться это `939`, и автобусы в эксплуатации `7`, `13`, `59`, `31` и `19`. Рядом с отметкой времени `939` эти автобусы отправляются в указанное время `D`:
```
time   bus 7   bus 13  bus 59  bus 31  bus 19
929      .       .       .       .       .
930      .       .       .       D       .
931      D       .       .       .       D
932      .       .       .       .       .
933      .       .       .       .       .
934      .       .       .       .       .
935      .       .       .       .       .
936      .       D       .       .       .
937      .       .       .       .       .
938      D       .       .       .       .
**939      .       .       .       .       .**
940      .       .       .       .       .
941      .       .       .       .       .
942      .       .       .       .       .
943      .       .       .       .       .
**944      .       .       D       .       .**
945      D       .       .       .       .
946      .       .       .       .       .
947      .       .       .       .       .
948      .       .       .       .       .
949      .       D       .       .       .
```

Самый ранний автобус, на котором вы можете сесть, - это идентификатор автобуса `59`. Он не отправляется до отметки времени `944`, поэтому вам придется подождать `944 - 939 = 5` минут, прежде чем он отправится. Умножение идентификатора автобуса на количество минут, которые вам нужно подождать, дает `295`.

Какой идентификатор первого автобуса, на котором вы можете добраться до аэропорта, умноженный на количество минут, которое вам нужно будет ждать этого автобуса?

### Решение

Для нахождения следующего времени прибытия автобуса после определенного времени нужно: 
- начальное время нацело разделить на периодичность автобуса, так получим сколько раз автобус уже приезжал.
- к количеству поездок прибавляем 1 и умножаем на периодичность, и получим время следующего приезда.

Проделаем это для каждого автобуса и найдем ближайшее время.

# Часть вторая
Компания-перевозчик проводит конкурс : одна золотая монета для всех, кто сможет найти самую раннюю метку времени, так что первый автобус отправляется в это время, а каждый последующий указанный автобус отправляется в следующую минуту. (Первая строка в вашем вводе больше не актуальна.)

Например, предположим, что у вас есть тот же список автобусов, что и выше:

`7,13,x,x,59,x,31,19`
Значок `x` в расписании означает, что нет ограничений на то, какие автобусы должны отправляться в это время.

Это означает, что вы ищете самую раннюю (называемую `t`) метку времени, такую, что:

- Идентификатор автобуса `7` отправляется во время `t`.
- Идентификатор автобуса `13` отправляется через одну минуту после времени `t`.
- Нет никаких требований или ограничений на отправления через две или три минуты после времени `t`.
- Идентификатор автобуса `59` отправляется через четыре минуты после времени `t`.
- Нет никаких требований или ограничений на отправления через пять минут после времени `t`.
- Идентификатор автобуса `31` отправляется через шесть минут после времени `t`.
- Идентификатор автобуса `19` отправляется через семь минут после времени `t`.

Единственные значения отправления автобусов - это перечисленные идентификаторы автобусов с их конкретным смещением от `t`. Эти автобусы могут отправляться в другое время, а другие автобусы могут отправляться в это время. Например, в приведенном выше списке, поскольку автобус `19` должен отправляться через семь минут после отметки времени, в которую отправляется автобус `7`, автобуса `7` всегда также будет отправляться с автобусом `19` через семь минут после отметки времени `t`.

В этом примере самая ранняя отметка времени, когда это происходит `1068781`:
```
time     bus 7   bus 13  bus 59  bus 31  bus 19
1068773    .       .       .       .       .
1068774    D       .       .       .       .
1068775    .       .       .       .       .
1068776    .       .       .       .       .
1068777    .       .       .       .       .
1068778    .       .       .       .       .
1068779    .       .       .       .       .
1068780    .       .       .       .       .
**1068781    D**       .       .       .       .
**1068782**    .       **D**       .       .       .
**1068783**    .       .       .       .       .
**1068784**    .       .       .       .       .
**1068785**    .       .       **D**       .       .
**1068786**    .       .       .       .       .
**1068787**    .       .       .       **D**       .
**1068788**    D       .       .       .       **D**
1068789    .       .       .       .       .
1068790    .       .       .       .       .
1068791    .       .       .       .       .
1068792    .       .       .       .       .
1068793    .       .       .       .       .
1068794    .       .       .       .       .
1068795    D       D       .       .       .
1068796    .       .       .       .       .
1068797    .       .       .       .       .
```

В приведенном выше примере автобус `7` отправляется на отметке времени `1068788`(через семь минут после `t`). Это отлично; единственное требование в эту минуту - отправление автобуса `19`, и это происходит.

Вот еще несколько примеров:

- Самое раннее время, соответствующая списку `17,x,13,19` - `3417`.
- `67,7,59,61` сначала происходит на отметке времени `754018`.
- `67,x,7,59,61` сначала происходит на отметке времени `779210`.
- `67,7,x,59,61` сначала происходит на отметке времени `1261476`.
- `1789,37,47,1889` сначала происходит на отметке времени `1202161486`.

Однако с таким количеством автобусов в вашем списке, несомненно, самая ранняя временная метка будет больше, чем `100000000000000`!

Какое самое раннее время, при которой все перечисленные автобусы отправляются со смещениями, соответствующими их позициям в списке?

### Решение

Сначала напишем функцию для нахождения времени пересечения для двух автобусов.
Проверяем значения начиная с `startValue` c шагом `step`, пока значение не удовлетворит условию. 
Для `17,x,13` начинаем с 0 повторяем с шагом 17 пока `(x+2)%13` не будет равно нулю.
```fsharp
let rec findCrossTwo startValue step bus offset  =
    let next = startValue + step
    if (next+offset)%bus=0L then next
    else findCrossTwo next step bus offset  
```
Выполним её для `17,x,13` несколько раз и получим `102, 323, 544, 765` и т.д. Из этого мы видим что разница между значениями одинаковая (221).
Повторим ещё раз для `17,x,x,19` и получим `187, 510, 833, 1156` и т.д. Разница 323.
То есть результат минус первое пересечение автобусов должно быть кратно разнице между следующими пересечениями.
Значит для `17,x,13,19` результат `x` должен соответствовать условиям:
```
(x - 102) % 221=0
(x - 187) % 323=0
```

Мы можем начать с первого пересечения `102` прибавлять разницу `221` и для каждого значения проверять соответствует ли оно всем условиям, но это занимает слишком много времени.

Попытаемся оптимизировать вычисление. 
Для поиска пересечений между первым (17) и третьим (19) автобусом возьмем данные полученные для второго (13).
В функцию `findCross` начальное значение (`startValue`) возьмем первое пересечение `102`, и шаг (`step`) разницу между пересечениями `221`.
Т.е. проверяем только те значения `x` которые удовлетворяют условию `(x - 102) % 221=0`

Разберем пример `67,7,59,61`
- Ищем пересечение между `67` и `7` получаем перевое `335``, разница `469`
- Ищем общее для `67,7,59` начинаем с `335` с шагом `469`, получаем перевое `6901`, разница `27671`
- Ищем последнее пересечение начинаем с `6901` с шагом `27671`, получаем `754018`

Для поиска переченчения и разницы будем использовать функцию
```fsharp
let findCross (startValue, step) (sndBus, offset)  = 
    let fstCross = findCrossTwo startValue step sndBus offset
    let sndCross = findCrossTwo fstCross step sndBus offset
    fstCross, sndCross-fstCross
```

Принимает на вход два кортежа (начальное значение * шаг) и (id автобуса * его смещение по рассписанию) 
и возвращает кортеж (первое пересечение * разница) который удобно подать обоатно на вход.
 
Подготовим входные данные: добавим к id автобуса их смещение по расписанию и уберем недействительные
```fsharp
let buses = input.Split(',') |> Array.mapi (fun i x -> (x, i)) |> Array.where (fun (x,_) -> x <> "x") |> Array.map (fun (f,i) -> (int64 f, int64 i))
```

Применим функцию `findCross` ко всем автобусам, нужное нам пересечения будет первым элементом получившегося кортежа.
```fsharp
Array.tail buses |> Array.fold findCross (0L, fst buses.[0]) |> fst
```

# День 14: Данные стыковки
## Часть первая 

Когда ваш паром приближается к морскому порту, капитан снова просит вас о помощи. Компьютерная система, на которой работает этот порт, несовместима с программой стыковки на пароме, поэтому параметры стыковки неправильно инициализируются в памяти стыковочной программы.

После краткого осмотра вы обнаруживаете, что компьютерная система морского порта использует странную систему битовых масок в своей программе инициализации. Хотя у вас под рукой нет нужного чипа декодера, вы можете эмулировать его с помощью программного обеспечения!

Программа инициализации (ввод вашей головоломки) может либо обновить битовую маску, либо записать значение в память. И значения, и адреса памяти представляют собой 36-битные целые числа без знака. Например, игнорируя на мгновение битовые маски, строка вроде `mem[8] = 11` записывает значение `11` по адресу памяти `8`.

Битовая маска всегда дается в виде строки из 36 битов, в которой старший бит (представляющий `2^35`) записывается слева, а младший бит (`2^0` то есть первый) - справа. Текущая битовая маска применяется к значениям непосредственно перед их записью в память: a `0` или `1` перезаписывает соответствующий бит в значении, в то время как `X` оставляет бит в значении неизменным.

Например, рассмотрим следующую программу:
```
mask = XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
mem[8] = 11
mem[7] = 101
mem[8] = 0
```

Эта программа начинается с указания битовой маски (`mask = ....`). Указанная маска будет перезаписывать два бита в каждом записанном значении: второй бит перезаписывается на `0`, а седьмой бит перезаписывается на `1`.

Затем программа пытается записать значение `11` по адресу памяти `8`. Раскладывая все до отдельных битов, маска применяется следующим образом:
```
value:  000000000000000000000000000000001011  (decimal 11)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001001001  (decimal 73)
```

Таким образом, из-за маски значение `73` записывается в адрес памяти `8`. Затем программа пытается записать `101` по адресу `7`:
```
value:  000000000000000000000000000001100101  (decimal 101)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001100101  (decimal 101)
```

На этот раз маска не действует, поскольку биты, которые она перезаписывает, теми же значениями, которые маска пыталась установить. Наконец, программа пытается написать `0` по адресу `8`:
```
value:  000000000000000000000000000000000000  (decimal 0)
mask:   XXXXXXXXXXXXXXXXXXXXXXXXXXXXX1XXXX0X
result: 000000000000000000000000000001000000  (decimal 64)
```

Dместо этого `64` записывается в адрес `8`, перезаписывая значение, которое было там ранее.

Чтобы инициализировать программу стыковки вашего парома, вам потребуется сумма всех значений, оставшихся в памяти после завершения программы инициализации. (Все 36-битное адресное пространство начинает инициализироваться значением `0` по каждому адресу.) В приведенном выше примере только два значения в памяти не равны нулю - `101`(по адресу `7`) и `64`(по адресу `8`) - что дает сумму `165`.

Запустите программу инициализации. Какова сумма всех значений, оставшихся в памяти после его завершения? (Не усекайте сумму до 36 бит.)

### Решение

Входные данные содержат битовую маску или данные для записи в память. Будем хранить их в размеченном объединении:
```fsharp
type Line =
    | Mask of string
    | Mem of int64 * int64
```

Прарсим входные данные при пмощи регулярных выражений
```fsharp
let parse str =
    let maskMatch = Regex.Match(str, @"mask = (\w+)")
    if maskMatch.Success then
        Mask maskMatch.Groups.[1].Value
    else
        let memMatch = Regex.Match(str, @"mem\[(\d+)] = (\d+)")
        Mem (int64 memMatch.Groups.[1].Value, int64 memMatch.Groups.[2].Value)
```



## Часть вторая

По какой-то причине компьютерная система морского порта все еще не может связаться с программой стыковки вашего парома. Он должен использовать версию 2 микросхемы декодера!

Микросхема декодера версии 2 вообще не изменяет записываемые значения. Вместо этого он действует как декодер адреса памяти. Непосредственно перед записью значения в память каждый бит битовой маски изменяет соответствующий бит адреса назначения в памяти следующим образом:

Если бит битовой маски равен `0`, соответствующий бит адреса памяти не изменяется.
Если бит битовой маски равен `1`, соответствующий бит адреса памяти перезаписывается на `1`.
Если бит битовой маски равен `X`, соответствующий бит адреса памяти является плавающим.
Плавающий бит не подключен ни к чему , а вместо этого меняется непредсказуемо. На практике это означает, что плавающие биты будут принимать все возможные значения, потенциально вызывая одновременную запись множества адресов памяти!

Например, рассмотрим следующую программу:
```
mask = 000000000000000000000000000000X1001X
mem[42] = 100
mask = 00000000000000000000000000000000X0XX
mem[26] = 1
```

Когда эта программа переходит на запись по адресу памяти `42`, она сначала применяет битовую маску:
```
address: 000000000000000000000000000000101010  (decimal 42)
mask:    000000000000000000000000000000X1001X
result:  000000000000000000000000000000X1101X
```
После применения маски перезаписываются четыре бита, три из которых разные, а два - плавающие. Плавающие биты принимают все возможные комбинации значений; с двумя плавающими битами записываются четыре фактических адреса памяти:
```
000000000000000000000000000000011010  (decimal 26)
000000000000000000000000000000011011  (decimal 27)
000000000000000000000000000000111010  (decimal 58)
000000000000000000000000000000111011  (decimal 59)
```

Далее программа собирается записать в память адрес `26` с другой битовой маской:
```
address: 000000000000000000000000000000011010  (decimal 26)
mask:    00000000000000000000000000000000X0XX
result:  00000000000000000000000000000001X0XX
```

В результате получается адрес с тремя плавающими битами, что приводит к записи в восемь адресов памяти:
```
000000000000000000000000000000010000  (decimal 16)
000000000000000000000000000000010001  (decimal 17)
000000000000000000000000000000010010  (decimal 18)
000000000000000000000000000000010011  (decimal 19)
000000000000000000000000000000011000  (decimal 24)
000000000000000000000000000000011001  (decimal 25)
000000000000000000000000000000011010  (decimal 26)
000000000000000000000000000000011011  (decimal 27)
```

Все 36-битное адресное пространство по-прежнему инициализируется значением `0` по каждому адресу, и вам по-прежнему нужна сумма всех значений, оставшихся в памяти в конце программы. В этом примере сумма равна `208`.

Выполните программу инициализации с помощью эмулятора для микросхемы декодера версии 2. Какова сумма всех значений, оставшихся в памяти после его завершения?

### Решение


